# Вопросы и ответы


## №1 Какой самый эффективный способ конкатенации строк?
```
Ответ:
strings.Builder
```

## №2 Что такое интерфейсы, как они применяются в Go?
```
Ответ:
Интерфейсы — это инструменты для определения наборов действий и поведения.

В GO интерфейсы используются по принципу duck-typing
```

## №3 Чем отличаются RWMutex от Mutex?
```
Ответ:
RWMutex в отличие от Mutex имеет два дополнительных метода RLock и RUnlock.
Они позволяют блокировать критическую секцию на запись, но при этом
не блокировать на чтение.
(В случае, если из другой горутины будет вызван метод RLock(), паники не будет,
однако если будет вызван метод Lock() возникнет паника)
```

## №4 Чем отличаются буферизированные и не буферизированные каналы?
```
Ответ:
Буферезированные каналы, в отличие от небуферезированных каналов имеют буффер.
В свою очередь запись в небуферизированный канал всегда блокирующая операция,
а в случае с буферезированным каналом горутина не будет блокироваться,
пока не будет заполнен буфер.
```

## №5 Какой размер у структуры struct{}{}?
```
Ответ:
0 Байт
```

## №6 Есть ли в Go перегрузка методов или операторов?
```
Ответ:
Нет
```

## №7 В какой последовательности будут выведены элементы map[int]int?
```
Ответ:
При итерации по map нет гарантии того, что элементы будутполучены каждый
раз одинаково, следовательно элементы будут выведены в случайно порядке.
```

## №8 В чем разница make и new?
```
Ответ:
Функция make() применими только к map, slice, channel и не возвращает указатель.

Функция new() выделяет нулевую память для нового элемента и возвращает
указатель.
```

## №9 Сколько существует способов задать переменную типа slice или map?
```
Ответ:
Существует 4 отличающихся способа для слайсов и 3 для карт

Для слайсов:
1) slice := []int{} // empty = true; nil = true
2) var slice []int // empty = true; nil = true
3) var slice = []int{nil} // empty = true; nil = false
4) slice := make([]int, 0) // empty = true; nil = false

Для карт:
1) var m map[string]struct{} // empty=true; nil=true 
2) m := map[string]struct{} // empty=true; nil=false
3) var m = make(map[string]struct{}) // empty=true; nil=false
```

## №10 Что выведет данная программа и почему?
```GO
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
```
Ответ:
```

## №11 Что выведет данная программа и почему?
```GO
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
```
Ответ:
```

## №12 Что выведет данная программа и почему?
```GO
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
```
Ответ:
```

## №13 Что выведет данная программа и почему?

```GO
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
```
Ответ:
```

## №14 Что выведет данная программа и почему?
```GO
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
```
Ответ:
```


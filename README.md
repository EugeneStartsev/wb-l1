# Вопросы и ответы


## №1 Какой самый эффективный способ конкатенации строк?
```
Ответ:
strings.Builder
```

## №2 Что такое интерфейсы, как они применяются в Go?
```
Ответ:
Интерфейсы — это инструменты для определения наборов действий и поведения.

В GO интерфейсы используются по принципу duck-typing
```

## №3 Чем отличаются RWMutex от Mutex?
```
Ответ:
RWMutex в отличие от Mutex имеет два дополнительных метода RLock и RUnlock.
Они позволяют блокировать критическую секцию на запись, но при этом
не блокировать на чтение.
(В случае, если из другой горутины будет вызван метод RLock(), паники не будет,
однако если будет вызван метод Lock() возникнет паника)
```

## №4 Чем отличаются буферизированные и не буферизированные каналы?
```
Ответ:
Буферезированные каналы, в отличие от небуферезированных каналов имеют буффер.
В свою очередь запись в небуферизированный канал всегда блокирующая операция,
а в случае с буферезированным каналом горутина не будет блокироваться,
пока не будет заполнен буфер.
```

## №5 Какой размер у структуры struct{}{}?
```
Ответ:
0 Байт
```

## №6 Есть ли в Go перегрузка методов или операторов?
```
Ответ:
Нет
```

## №7 В какой последовательности будут выведены элементы map[int]int?
```
Ответ:
При итерации по map нет гарантии того, что элементы будутполучены каждый
раз одинаково, следовательно элементы будут выведены в случайно порядке.
```

## №8 В чем разница make и new?
```
Ответ:
Функция make() применими только к map, slice, channel и не возвращает указатель.

Функция new() выделяет нулевую память для нового элемента и возвращает
указатель.
```

## №9 Сколько существует способов задать переменную типа slice или map?
```
Ответ:
Существует 4 отличающихся способа для слайсов и 3 для карт

Для слайсов:
1) slice := []int{} // empty = true; nil = true
2) var slice []int // empty = true; nil = true
3) var slice = []int{nil} // empty = true; nil = false
4) slice := make([]int, 0) // empty = true; nil = false

Для карт:
1) var m map[string]struct{} // empty=true; nil=true 
2) m := map[string]struct{} // empty=true; nil=false
3) var m = make(map[string]struct{}) // empty=true; nil=false
```

## №10 Что выведет данная программа и почему?
```GO
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
```
Ответ:
Будет выведено 1, 1, так как в функцию update передается копия указателя на a который 
меняется на указатель на b. Чтобы вывелось 1, 2 необходимо вернуть значение p (return p)
и присвоить p в функции main.
```

## №11 Что выведет данная программа и почему?
```GO
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
```
Ответ:
Будет deadlock, так как переменная wg копируется, из-за чего в горутинах не будет отщелкнут
счетчик, что приведт к зависанию программы на wg.Wait(). Чтобы исправить это необходимо
передать переменную wg по указателю или через замыкание.
```

## №12 Что выведет данная программа и почему?
```GO
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
```
Ответ:
0, так как область видимости переменной n, объявленной в if будет ограничиваться 
областью видимости ветвления, и она сотрется после окончания ветвления.
```

## №13 Что выведет данная программа и почему?

```GO
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
```
Ответ:
Слайс из себя представляет структуру с 3-мя полями, одно из которых - указатель на
резервный массив. Когда мы передает эту структуру в функцию someAction, то происходит
копирование, в том числе и указателя. Из-за чего мы можем изменить v[0] на 100 и это
отобразится в изначальном срезе, однако после того, как мы вставим 6 элемент в слайс,
append вернет новую структуру, что перезапишется в переменную v. Следовательно
 a = []int{100,2,3,4,5} после выполнения функции.
```

## №14 Что выведет данная программа и почему?
```GO
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
```
Ответ:
Так как в этой ситуции сначала происходит вставка, то переменной slice внутри
анонимной функции будет присвоена новая структура, где буду заменены 0 и 1 элементы на b,
при этом слайс из main функции будет не тронут, что в свою очередь приведет к следующему
выводу: [b,b,a][a,a]. 
```

